class DepartmentReview < ApplicationRecord
# Ossemble's Main Department Model for Department Reviews, feeds into 5 score tables: GovernmentScore, ParkScore, SchoolScore, PoliceScore, and PublicScore.

# Begin - Gems and acts_as setups. 
  # Below - PUBLICACTIVITY: Loads in Public Activity Gem for tracking of users' comments
  include PublicActivity::Model
  # Below - Adds Tracking to this model for PubliCActivity
  tracked
  # Below - FRIENDLYID: Adding FriendlyID to URL as title instead of ID. 
  extend FriendlyId
  friendly_id :title, use: [:slugged, :finders]
  # Below - Determines if there's a blank or new Record to assign a slug to.
  def should_generate_new_friendly_id?
    new_record? || slug.blank?
  end
  # PUNCHABLE: Sets up for punching bag hits (trending).
  acts_as_punchable
  # Below - RATYRATE: Adding RatyRate function inside of Reviews to allow Reviews to affect Departments.
  ratyrate_rateable 'score'
  # Below - TAGGABLE: Allows Acts_as_taggable  from the acts_as_taggable gem.
  acts_as_taggable_on :love, :improve
  # Below - ACTS_AS_VOTABLE - Acts_as_votable gem to allow upvotes on Department Reviews.
  acts_as_votable
  # Below - ACTS AS FOLLOWER: Allows following.
  #acts_as_followable
# End - Gems and acts_as setups. 

# Begin - Scopes for Departments. 
  # Below - Orders City Reviews that have been recently updated/created to the top of the list.
  default_scope { order(created_at: :desc)}
  # Below - Sorts Government Departments. 
  scope :government, -> { where(scorable_type: "GovernmentScore")}
  # Below - Sorts School Departments.
  scope :schools, -> { where(scorable_type: "SchoolScore")}
  # Below - Sorts Parks Departments.
  scope :parks, -> { where(scorable_type: "ParkScore")}
  # Below - Sorts Police Departments.
  scope :police, -> { where(scorable_type: "PoliceScore")}
  # Below - Sorts Public Works Departments.
  scope :public_works, -> { where(scorable_type: "PublicScore")}
  
# End - Scopes for Departments.

# Begin - VALIDATIONS: Additional validations of DB field attributes presence at Model-level, Uniqueness and Character Limitations.
  # Below - Ensures the user can only post one WUL City Review.
  #validates_uniqueness_of :user_id, presence: true, message: "You have already written a What You Love review for your city." 
  # Below - Ensures the review includes a score 1 through 100.
  validates_inclusion_of :score, in: 1..100, message: 'Please select a score rating for this department.'
  # Below - Ensures the title of the review is at least 4 characters and 60 maximum, allows blank since a title can be generated by callback below.
  validates_length_of :title,  :minimum => 1, :maximum => 70, 
    :too_long => "We appreciate how descriptive you are, but the maximum characters for a title is 70 characters. Please be more succinct.", 
    :too_short => "Please include a review title. The maximum length is 70 characters.", 
    :allow_blank => true
  # Below - Ensures length of review description is at least 150 characters and 3000 maximum.
  validates_length_of :description,  :minimum => 100, :maximum => 6000, 
    :too_long => "We appreciate how descriptive you are, but the maximum characters for a review is 6,000 characters, which is about 900 words. Please be more succinct.", 
    :too_short => "We strive for quality reviews so everyone can benefit. The minimum character length for a review is 100 characters, which is about 10 words. Please include more detail in your review by adding additional information about your experience." 
  # Below - Ensures love tags are included in a review.
  validates_presence_of :love_list, message: "Please include three things you like about this city's department; separated by commas. ( EG: 'Staff, Communication, Engagement' )."
  # Below - Ensures improve tags are included in a review.
  validates_presence_of :improve_list, message: "Please include three things that need improvement concerning this city's department; separated by commas. ( EG: 'Red Tape, Regulations, Helpfulness' )."
  # Below - Ensures the presence of a Category Type polymorphic association.
  validates :scorable_type, presence: { message: "Please select which department category you'd like to review." }
# End - VALIDATIONS: Additional validations of DB field attributes presence at Model-level and Character Limitations.
  
# Begin - ASSOCIATIONS: All Associations of Department Table to other tables (One to Many - City_score & One to Many - Department_Category & Has Many and Belongs - Reviews).
  # Below - Associates Department Reviews with users using user_id, as a One to Many relationship (users has_many department_reviews). 
  belongs_to :user 
  # Below - Polymorphic association for departments with scorable through the *_score tables.
  belongs_to :scorable, :polymorphic => true
  # Below - Associates DepartmentReview into a One to Many association with City (City has_many department_reviews).
  belongs_to :city
  # Below - Associates DepatmentReview have a many to belongs to relationship with comments.  Comments are destroyed if a Department Review is.
  has_many :comments, :as => :commentable, dependent: :destroy
  #  Below - Allows an image upload of department reviews for active storage.
  has_one_attached :image, dependent: :destroy
  # Below - Allows Scorable fields to be accessed by department reviews so that "update_category_score" can properly run the *_score models. 
  accepts_nested_attributes_for :scorable
# End - ASSOCIATIONS: All Associations of Department Table to other tables.

# Begin - METHODS: Custom methods and calls.
  # Below - Determines category of department.
  def category
    case self.scorable_type
    when "GovernmentScore"
      return "Government"
    when "ParkScore"
      return "Parks"
    when "SchoolScore"
      return "Schools"
    when "PoliceScore"
      return "Police"
    when "PublicScore"
      return "Public Works"
    end
  end
  
  # Below -  Checks if the review is done by a resident of the reviewed city, using is_resident_of? method from user.rb model.
  def is_resident_review?
    user_review = self.user 
    if user_review != nil
      user_review = self.user
      if user_review.is_resident_of?(self.city)
        return true 
      else
        return false
      end 
    else 
      return false 
    end 
  end   
  
  # Below -  Checks if the review has enough votes to be considered scorable. Uses the method below to return votes from residents of that department review's city.
  def has_enough_votes?
    if self.resident_upvotes.count >= 5
      return true 
    else 
      return false
    end 
  end   

  # Below -  Checks if the review will impact the city score. Determining factors are if the user belongs to that city, or if the non-resident user's review has 5 endorsements
  def is_scorable_review? 
    if self.is_resident_review?
      return true # Review belongs to resident of the city, so it's scorable.
    elsif self.has_enough_votes? # Reviewer isn't resident of city being review, so does the review have enough votes to be scorable
      return true  # Has enough votes to affect city score 
    else # Review doesn't have enough votes and is a non-resident review.
      return false
    end 
  end   
  # Below -  A scope to filter scorable reviews.
  def scorable_reviews
    self.select { |review| review.is_scorable_review? == true }
  end   
  
  # Below -  A scope to filter votes by residents of the city where the review was posted.
  def resident_upvotes 
     self.votes_for.voters.select { |user| user.city == self.city }
  end   
# End - METHODS: Custom methods and calls.

# Begin - CUSTOM CALLBACKS: Before_save, after_commit, & Callbacks.
  # Below - On the updating of a Departments' score from the addition of a new Review, by means of the method "update_avg_score".
  after_commit :update_scorable_tables, on: [:create, :update, :destroy]
  # Below - Callback for Generating a title if one is left blank on a new or updated Department Review.
  before_save :generate_department_review_title, on: [:create, :update], if: :title_blank?
  
  # Below - First Conditional callback which will determine if the review title is blank or not
    def title_blank?
      self.title.blank?
    end
  # Below - Generates a title for a department review if it's left blank. 
    def generate_department_review_title 
      review_type = self.scorable_type
      case review_type
      when "GovernmentScore"
        self.title = "#{self.user.name}'s Government Review"
      when "ParkScore"
        self.title = "#{self.user.name}'s Parks Review"
      when "SchoolScore"
        self.title = "#{self.user.name}'s Schools Review"
      when "PoliceScore"
        self.title = "#{self.user.name}'s Police Review"
      when "PublicScore"
        self.title = "#{self.user.name}'s Public Works Review"
      end
    end 
  
  # Below - Updates the corresponding score related to the department when a review is newly added.
  def update_scorable_tables
    department_category = self.scorable_type
    case department_category
    when "GovernmentScore"
      self.scorable.update_government_avg_score
    when "SchoolScore"
      self.scorable.update_school_avg_score
    when "ParkScore"
      self.scorable.update_park_avg_score
    when "PoliceScore"
      self.scorable.update_police_avg_score
    when "PublicScore"
      self.scorable.update_public_avg_score
    end
  end
# End - CUSTOM CALLBACKS: Before_save, after_commit, & Callbacks.

end
